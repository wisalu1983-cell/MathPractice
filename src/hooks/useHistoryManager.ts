import { useCallback, useState, useEffect } from 'react';
import { HistoryRecord, GameSession, IncompleteHistoryRecord } from '../types';
import type { HistoryRecord as ServerHistoryRecord } from '../types/supabase';
import { useLocalStorage } from './useLocalStorage';

export const useHistoryManager = () => {
  const [historyRecords, setHistoryRecords] = useLocalStorage<HistoryRecord[]>('historyRecords', []);
  const [incompleteHistoryRecords, setIncompleteHistoryRecords] = useLocalStorage<IncompleteHistoryRecord[]>('incompleteHistoryRecords', []);
  const [refreshTrigger, setRefreshTrigger] = useState(0);

  // ÁõëÂê¨refreshTriggerÂèòÂåñÔºåÂº∫Âà∂ÈáçÊñ∞ËØªÂèñlocalStorage
  useEffect(() => {
    if (refreshTrigger > 0) {
      try {
        const storedRecords = localStorage.getItem('historyRecords');
        if (storedRecords) {
          try {
            const parsedRecords = JSON.parse(storedRecords);
            setHistoryRecords(parsedRecords);
          } catch (parseError) {
            console.error('Failed to parse history records:', parseError);
            // Â¶ÇÊûúËß£ÊûêÂ§±Ë¥•ÔºåÊ∏ÖÈô§ÊçüÂùèÁöÑÊï∞ÊçÆ
            localStorage.removeItem('historyRecords');
            setHistoryRecords([]);
          }
        }

        const storedIncomplete = localStorage.getItem('incompleteHistoryRecords');
        if (storedIncomplete) {
          try {
            const parsedIncomplete = JSON.parse(storedIncomplete);
            setIncompleteHistoryRecords(parsedIncomplete);
          } catch (parseError) {
            console.error('Failed to parse incomplete history records:', parseError);
            // Â¶ÇÊûúËß£ÊûêÂ§±Ë¥•ÔºåÊ∏ÖÈô§ÊçüÂùèÁöÑÊï∞ÊçÆ
            localStorage.removeItem('incompleteHistoryRecords');
            setIncompleteHistoryRecords([]);
          }
        }
      } catch (error) {
        console.error('Failed to refresh records from localStorage:', error);
      }
    }
  }, [refreshTrigger]); // ÁßªÈô§setHistoryRecordsÂíåsetIncompleteHistoryRecords‰æùËµñÔºåÈÅøÂÖçÊó†ÈôêÂæ™ÁéØ

  // ‰øùÂ≠òÂçïÊù°Á≠îÈ¢òËÆ∞ÂΩï
  const saveRecord = useCallback((session: GameSession, userId: string): string => {
    if (!session.isCompleted || !userId) return '';

    const timeSpent = session.endTime && session.startTime 
      ? Math.round((session.endTime - session.startTime) / 1000) 
      : 0;

    const accuracy = session.totalProblems > 0 
      ? Math.round((session.correctAnswers / session.totalProblems) * 100) 
      : 0;

    const averageTime = session.totalProblems > 0 
      ? Math.round(timeSpent / session.totalProblems) 
      : 0;

    const record: HistoryRecord = {
      id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
      userId,
      date: session.endTime || Date.now(),
      problemType: session.problemType!,
      difficulty: session.difficulty!,
      totalProblems: session.totalProblems,
      correctAnswers: session.correctAnswers,
      accuracy,
      totalTime: timeSpent,
      averageTime,
      problems: session.problems,
      answers: session.answers,
      answerTimes: session.answerTimes,
      score: session.score
    };

    setHistoryRecords(prev => [record, ...prev]);
    // ‰øùÂ≠òÂÆåÊàêËÆ∞ÂΩïÂêéÔºåÊ∏ÖÈô§ÂØπÂ∫îÊú™ÂÆåÊàêËÆ∞ÂΩï
    if (session.sessionId) {
      setIncompleteHistoryRecords(prev => prev.filter(r => r.sessionId !== session.sessionId));
    }
    return record.id;
  }, [setHistoryRecords, setIncompleteHistoryRecords]);

  // ÊâπÈáè‰øùÂ≠òËÆ∞ÂΩï
  const saveRecords = useCallback((sessions: GameSession[], userId: string): string[] => {
    if (!userId || sessions.length === 0) return [];

    const newRecords: HistoryRecord[] = [];
    const recordIds: string[] = [];

    sessions.forEach(session => {
      if (!session.isCompleted) return;

      const timeSpent = session.endTime && session.startTime 
        ? Math.round((session.endTime - session.startTime) / 1000) 
        : 0;

      const accuracy = session.totalProblems > 0 
        ? Math.round((session.correctAnswers / session.totalProblems) * 100) 
        : 0;

      const averageTime = session.totalProblems > 0 
        ? Math.round(timeSpent / session.totalProblems) 
        : 0;

      const recordId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
      
      const record: HistoryRecord = {
        id: recordId,
        userId,
        date: session.endTime || Date.now(),
        problemType: session.problemType!,
        difficulty: session.difficulty!,
        totalProblems: session.totalProblems,
        correctAnswers: session.correctAnswers,
        accuracy,
        totalTime: timeSpent,
        averageTime,
        problems: session.problems,
        answers: session.answers,
        answerTimes: session.answerTimes,
        score: session.score
      };

      newRecords.push(record);
      recordIds.push(recordId);
    });

    // ‰∏ÄÊ¨°ÊÄßÊâπÈáèÊõ¥Êñ∞ÊâÄÊúâËÆ∞ÂΩï
    setHistoryRecords(prev => [...newRecords, ...prev]);
    return recordIds;
  }, [setHistoryRecords]);

  // Âº∫Âà∂Âà∑Êñ∞ÂéÜÂè≤ËÆ∞ÂΩïÔºà‰ªélocalStorageÈáçÊñ∞ËØªÂèñÔºâ
  const refreshRecords = useCallback(() => {
    setRefreshTrigger(prev => prev + 1);
    
    // üîß È¢ùÂ§ñÁöÑÂº∫Âà∂Âà∑Êñ∞Êú∫Âà∂ÔºöÁõ¥Êé•ÈáçÊñ∞ËÆæÁΩÆÁä∂ÊÄÅ
    try {
      const storedRecords = localStorage.getItem('historyRecords');
      if (storedRecords) {
        const parsedRecords = JSON.parse(storedRecords);
        console.log('[refreshRecords] Âº∫Âà∂Êõ¥Êñ∞ÂÆåÊàêËÆ∞ÂΩïÁä∂ÊÄÅ:', parsedRecords.length);
        setHistoryRecords([...parsedRecords]); // ÂàõÂª∫Êñ∞Êï∞ÁªÑÂº∫Âà∂Êõ¥Êñ∞
      }

      const storedIncomplete = localStorage.getItem('incompleteHistoryRecords');
      if (storedIncomplete) {
        const parsedIncomplete = JSON.parse(storedIncomplete);
        console.log('[refreshRecords] Âº∫Âà∂Êõ¥Êñ∞Êú™ÂÆåÊàêËÆ∞ÂΩïÁä∂ÊÄÅ:', parsedIncomplete.length);
        setIncompleteHistoryRecords([...parsedIncomplete]); // ÂàõÂª∫Êñ∞Êï∞ÁªÑÂº∫Âà∂Êõ¥Êñ∞
      }
    } catch (error) {
      console.error('[refreshRecords] Âº∫Âà∂Âà∑Êñ∞Â§±Ë¥•:', error);
    }
    
    return true;
  }, [setHistoryRecords, setIncompleteHistoryRecords]);

  // Ëé∑ÂèñÁî®Êà∑ÁöÑÂéÜÂè≤ËÆ∞ÂΩï
  const getUserRecords = useCallback((userId: string): HistoryRecord[] => {
    return historyRecords
      .filter(record => record.userId === userId)
      .sort((a, b) => b.date - a.date); // ÊåâÊó∂Èó¥ÈôçÂ∫èÊéíÂàó
  }, [historyRecords]);

  // Ê†πÊçÆIDËé∑ÂèñÁâπÂÆöËÆ∞ÂΩï
  const getRecordById = useCallback((recordId: string): HistoryRecord | null => {
    return historyRecords.find(record => record.id === recordId) || null;
  }, [historyRecords]);

  // Âà†Èô§ËÆ∞ÂΩï
  const deleteRecord = useCallback((recordId: string): boolean => {
    setHistoryRecords(prev => prev.filter(record => record.id !== recordId));
    return true;
  }, [setHistoryRecords]);



  // Ê∏ÖÁ©∫Áî®Êà∑ÁöÑÊâÄÊúâËÆ∞ÂΩï
  const clearUserRecords = useCallback((userId: string): boolean => {
    setHistoryRecords(prev => prev.filter(record => record.userId !== userId));
    return true;
  }, [setHistoryRecords]);

  // Ëé∑ÂèñÁî®Êà∑ÁªüËÆ°‰ø°ÊÅØ
  const getUserStats = useCallback((userId: string) => {
    const userRecords = getUserRecords(userId);
    
    if (userRecords.length === 0) {
      return {
        totalSessions: 0,
        totalProblems: 0,
        totalCorrectAnswers: 0,
        averageAccuracy: 0,
        totalTimeSpent: 0,
        bestAccuracy: 0,
        recentSessions: []
      };
    }

    const totalSessions = userRecords.length;
    const totalProblems = userRecords.reduce((sum, record) => sum + record.totalProblems, 0);
    const totalCorrectAnswers = userRecords.reduce((sum, record) => sum + record.correctAnswers, 0);
    const averageAccuracy = totalProblems > 0 ? Math.round((totalCorrectAnswers / totalProblems) * 100) : 0;
    const totalTimeSpent = userRecords.reduce((sum, record) => sum + record.totalTime, 0);
    const bestAccuracy = Math.max(...userRecords.map(record => record.accuracy));
    const recentSessions = userRecords.slice(0, 5); // ÊúÄËøë5Ê¨°

    return {
      totalSessions,
      totalProblems,
      totalCorrectAnswers,
      averageAccuracy,
      totalTimeSpent,
      bestAccuracy,
      recentSessions
    };
  }, [getUserRecords]);

  return {
    historyRecords,
    saveRecord,
    saveRecords,
    refreshRecords,
    getUserRecords,
    getRecordById,
    deleteRecord,
    clearUserRecords,
    getUserStats,

    // Êú™ÂÆåÊàêËÆ∞ÂΩïÁõ∏ÂÖ≥
    incompleteHistoryRecords,
    upsertIncompleteRecord: (session: GameSession, userId: string, overrideDate?: number) => {
      if (!userId || !session.isActive || session.isCompleted) return false;
      if (!session.problemType || !session.difficulty) return false;

      // ÁªüËÆ°Â∑≤‰ΩúÁ≠îÊï∞Èáè‰∏éÊó∂Èó¥
      const answeredCount = session.answers.filter(a => a !== undefined).length;
      const correctAnswers = session.correctAnswers;
      const accuracy = session.totalProblems > 0 && answeredCount > 0
        ? Math.round((correctAnswers / answeredCount) * 100)
        : 0;
      const totalTime = session.answerTimes.filter(t => typeof t === 'number').reduce((s, t) => s + (t || 0), 0);
      const averageTime = answeredCount > 0 ? Math.round(totalTime / answeredCount) : 0;

      const now = typeof overrideDate === 'number' ? overrideDate : Date.now();
      const record: IncompleteHistoryRecord = {
        id: session.sessionId || `${userId}_${now}`,
        sessionId: session.sessionId || `${userId}_${now}`,
        userId,
        date: now,
        problemType: session.problemType,
        difficulty: session.difficulty,
        totalProblems: answeredCount,
        correctAnswers,
        accuracy,
        totalTime,
        averageTime,
        problems: session.problems,
        answers: session.answers,
        answerTimes: session.answerTimes,
        score: session.score,
        plannedTotalProblems: session.totalProblems,
        synced: false, // Êñ∞ËÆ∞ÂΩïÈªòËÆ§Êú™ÂêåÊ≠•
        timestamp: now // ËÆ∞ÂΩïÂàõÂª∫Êó∂Èó¥
      };

      setIncompleteHistoryRecords(prev => {
        const idx = prev.findIndex(r => r.sessionId === record.sessionId && r.userId === userId);
        if (idx >= 0) {
          const cloned = prev.slice();
          // Êõ¥Êñ∞Êó∂‰øùÁïôÂ∑≤ÊúâÁöÑ synced Áä∂ÊÄÅÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
          const existingRecord = cloned[idx];
          cloned[idx] = {
            ...record,
            synced: existingRecord.synced ?? false // ‰øùÁïôÂéüÊúâÂêåÊ≠•Áä∂ÊÄÅÊàñÈªòËÆ§‰∏∫ false
          };
          return cloned;
        }
        return [record, ...prev];
      });
      return true;
    },
    // Â∞ÜÊúçÂä°Âô®ËÆ∞ÂΩïÂêàÂπ∂Âà∞Êú¨Âú∞ÔºàÂéªÈáçÔºö‰ª• client_id ‰Ωú‰∏∫‰∏ªÈîÆÔºâ
    // ÂÖºÂÆπ‚ÄúÊóßÊú¨Âú∞Áî®Êà∑‰øùÁïô‚ÄùÁ≠ñÁï•Ôºö
    // Ëã•Êú¨Âú∞Â∑≤Â≠òÂú®Áõ∏Âêå client_idÔºå‰ΩÜÂΩíÂ±û‰∏∫ÂÖ∂ÂÆÉÊú¨Âú∞Áî®Êà∑ÔºåÂàô‰∏çË¶ÜÁõñÂéüËÆ∞ÂΩïÔºå
    // ËÄåÊòØ‰∏∫Âú®Á∫øË¥¶Âè∑ÁîüÊàê‰∏Ä‰∏™Âà´ÂêçIDÔºàuserId_clientIdÔºâÂä†ÂÖ•ÔºåÈÅøÂÖçÊ∏ÖÁ©∫ÊóßÊú¨Âú∞Áî®Êà∑ÁöÑÊï∞ÊçÆ„ÄÇ
    mergeServerRecords: (serverRecords: ServerHistoryRecord[], userId: string) => {
      if (!Array.isArray(serverRecords) || serverRecords.length === 0) return 0;

      let affected = 0;
      setHistoryRecords(prev => {
        const byId = new Map(prev.map(r => [r.id, r]));
        const updates = new Map<string, HistoryRecord>();
        const toAppend: HistoryRecord[] = [];

        for (const s of serverRecords) {
          if (s.user_id !== userId) continue;
          const clientId = (s.client_id || '').toString();
          if (!clientId) continue;

          let canonical: HistoryRecord = {
            id: clientId,
            userId: userId,
            date: new Date(s.date).getTime(),
            problemType: s.problem_type,
            difficulty: s.difficulty,
            totalProblems: s.total_problems,
            correctAnswers: s.correct_answers,
            accuracy: typeof s.accuracy === 'number' ? Math.round(s.accuracy) : Number(s.accuracy || 0),
            totalTime: s.total_time,
            averageTime: typeof s.average_time === 'number' ? Math.round(s.average_time) : Number(s.average_time || 0),
            problems: (s.problems ?? []) as any,
            answers: (s.answers ?? []) as any,
            answerTimes: (s.answer_times ?? []) as number[],
            score: s.score,
          };

          const local = byId.get(clientId);
          if (local) {
            if (local.userId !== userId) {
              // ‰∏•ÈáçÂÜ≤Á™ÅÔºöÂêå‰∏Ä‰∏™ client_id Â±û‰∫é‰∏çÂêåÁî®Êà∑
              // ËøôË°®ÊòéÊï∞ÊçÆÂÆåÊï¥ÊÄßÂá∫Áé∞ÈóÆÈ¢òÔºåÈúÄË¶ÅËÆ∞ÂΩïÂπ∂Ë∞®ÊÖéÂ§ÑÁêÜ
              console.warn(`[mergeServerRecords] Êï∞ÊçÆÂÜ≤Á™Å: client_id ${clientId} Âú®Êú¨Âú∞Â±û‰∫éÁî®Êà∑ ${local.userId}, ‰ΩÜÊúçÂä°Á´ØÂ±û‰∫éÁî®Êà∑ ${userId}`);
              
              // ÈááÁî®‰øùÂÆàÁ≠ñÁï•Ôºö‰øùÁïôÊú¨Âú∞Êï∞ÊçÆÔºå‰∏∫ÊúçÂä°Á´ØÊï∞ÊçÆÁîüÊàêÊñ∞ÁöÑID
              // ËøôÊ†∑ÂèØ‰ª•ÈÅøÂÖçÊï∞ÊçÆ‰∏¢Â§±Ôºå‰ΩÜÈúÄË¶ÅÂêéÁª≠‰∫∫Â∑•Â§ÑÁêÜ
              const conflictId = `conflict_${Date.now()}_${clientId}`;
              canonical = { ...canonical, id: conflictId };
              
              // ËÆ∞ÂΩïÂÜ≤Á™Å‰ø°ÊÅØÔºå‰æõÂêéÁª≠ÂàÜÊûê
              console.error(`[mergeServerRecords] ÂàõÂª∫ÂÜ≤Á™ÅËÆ∞ÂΩï: ${conflictId}, ÂéüÂßãÊúçÂä°Á´ØÊï∞ÊçÆ:`, s);
              
              toAppend.push(canonical);
              affected += 1;
              
              // TODO: Âú®Áîü‰∫ßÁéØÂ¢É‰∏≠ÔºåÂ∫îËØ•Â∞ÜÂÜ≤Á™Å‰ø°ÊÅØÂèëÈÄÅÂà∞ÁõëÊéßÁ≥ªÁªü
              // Áî®‰∫éÂàÜÊûêÊï∞ÊçÆ‰∏ÄËá¥ÊÄßÈóÆÈ¢òÁöÑÊ†πÊú¨ÂéüÂõ†
            } else {
              // Âêå‰∏ÄË¥¶Âè∑‰∏ãÔºåÊ£ÄÊü•Êï∞ÊçÆÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞
              // ‰ΩøÁî®Êõ¥ÂÖ®Èù¢ÁöÑÊØîËæÉÁ≠ñÁï•ÔºåÂåÖÊã¨Ê†∏ÂøÉÊï∞ÊçÆÂ≠óÊÆµ
              const needsUpdate = (
                local.date !== canonical.date ||
                local.score !== canonical.score ||
                local.correctAnswers !== canonical.correctAnswers ||
                local.totalProblems !== canonical.totalProblems ||
                local.accuracy !== canonical.accuracy ||
                local.totalTime !== canonical.totalTime
              );
              
              if (needsUpdate) {
                // ‰ºòÂÖà‰ΩøÁî®ÊúÄÊñ∞ÁöÑÊï∞ÊçÆÔºàÂü∫‰∫éÊó•ÊúüÔºâ
                if (canonical.date >= local.date) {
                  updates.set(clientId, canonical);
                  affected += 1;
                } else {
                  // Êú¨Âú∞Êï∞ÊçÆÊõ¥Êñ∞Ôºå‰øùÁïôÊú¨Âú∞Êï∞ÊçÆ
                  console.log(`[mergeServerRecords] ‰øùÁïôÊú¨Âú∞ËæÉÊñ∞Êï∞ÊçÆ: ${clientId}`);
                }
              }
            }
          } else {
            // Êñ∞Êï∞ÊçÆÔºåÁõ¥Êé•Ê∑ªÂä†
            toAppend.push(canonical);
            affected += 1;
          }
        }

        if (updates.size === 0 && toAppend.length === 0) return prev;

        const next = prev.map(r => updates.get(r.id) ?? r);
        if (toAppend.length > 0) next.unshift(...toAppend);
        return next;
      });

      return affected;
    },
    getUserIncompleteRecords: (userId: string): IncompleteHistoryRecord[] => {
      return incompleteHistoryRecords
        .filter(r => r.userId === userId)
        .sort((a, b) => b.date - a.date);
    },
    removeIncompleteBySession: (sessionId: string) => {
      setIncompleteHistoryRecords(prev => prev.filter(r => r.sessionId !== sessionId));
      return true;
    },
    clearUserIncompleteRecords: (userId: string) => {
      setIncompleteHistoryRecords(prev => prev.filter(r => r.userId !== userId));
      return true;
    },
    // Ê∏ÖÁêÜÈáçÂ§çÁöÑÊú™ÂÆåÊàêËÆ∞ÂΩïÔºà‰øÆÂ§çÂéªÈáçbugÂêéÁöÑÊï∞ÊçÆÊ∏ÖÁêÜÔºâ
    cleanupDuplicateIncompleteRecords: (userId: string) => {
      setIncompleteHistoryRecords(prev => {
        console.log(`[cleanupDuplicateIncompleteRecords] ÂºÄÂßãÊ∏ÖÁêÜÁî®Êà∑ ${userId} ÁöÑÈáçÂ§çËÆ∞ÂΩïÔºåÂΩìÂâçÊï∞Èáè: ${prev.length}`);
        
        // ÊåâsessionIdÂéªÈáçÔºå‰øùÁïôÊúÄÊñ∞ÁöÑËÆ∞ÂΩï
        const seen = new Map<string, IncompleteHistoryRecord>();
        const cleaned = prev.filter(record => {
          if (record.userId !== userId) return true; // ‰øùÁïôÂÖ∂‰ªñÁî®Êà∑ÁöÑËÆ∞ÂΩï
          
          const key = record.sessionId || record.id;
          const existing = seen.get(key);
          
          if (!existing) {
            seen.set(key, record);
            return true;
          }
          
          // ‰øùÁïôÊõ¥Êñ∞ÁöÑËÆ∞ÂΩïÔºàÂü∫‰∫édateÂ≠óÊÆµÔºâ
          if (record.date > existing.date) {
            seen.set(key, record);
            return true;
          }
          
          return false; // ‰∏¢ÂºÉÈáçÂ§çÁöÑÊóßËÆ∞ÂΩï
        });
        
        console.log(`[cleanupDuplicateIncompleteRecords] Ê∏ÖÁêÜÂÆåÊàêÔºå‰ªé ${prev.length} Êù°ÂáèÂ∞ëÂà∞ ${cleaned.length} Êù°`);
        return cleaned;
      });
    },
    
    // ÂêàÂπ∂ÊúçÂä°Á´ØÊú™ÂÆåÊàêËÆ∞ÂΩï
    mergeServerIncompleteRecords: (serverRecords: any[], userId: string) => {
      console.log(`[mergeServerIncompleteRecords] ÂºÄÂßãÂêàÂπ∂ ${serverRecords.length} Êù°ÊúçÂä°Á´ØÊú™ÂÆåÊàêËÆ∞ÂΩï`);
      console.log(`[mergeServerIncompleteRecords] ÊúçÂä°Á´ØËÆ∞ÂΩïËØ¶ÊÉÖ:`, serverRecords);
      
      // üîß Âü∫‰∫éÂΩìÂâçÁä∂ÊÄÅËøõË°åÂéªÈáçÂíåÂêàÂπ∂ÔºåÈÅøÂÖçÁä∂ÊÄÅ‰∏çÂêåÊ≠•
      const current = incompleteHistoryRecords;
      console.log(`[mergeServerIncompleteRecords] ÂΩìÂâçÊú¨Âú∞ËÆ∞ÂΩïÊï∞: ${current.length}`);
      
      // È¢ÑÂÖàÂ§ÑÁêÜÊï∞ÊçÆÂπ∂ËÆ°ÁÆóaffected
      const processedData = (() => {
        // Âú®ÂÜÖÂ≠ò‰∏≠ÂéªÈáçÔºå‰∏çÁ´ãÂç≥Êõ¥Êñ∞Áä∂ÊÄÅ
        const seen = new Map<string, IncompleteHistoryRecord>();
        const dedupedCurrent = current.filter(record => {
          const key = record.sessionId || record.id;
          if (seen.has(key)) {
            console.log(`[mergeServerIncompleteRecords] ÂèëÁé∞ÈáçÂ§çÊú¨Âú∞ËÆ∞ÂΩïÔºåË∑≥Ëøá: ${key}`);
            return false;
          }
          seen.set(key, record);
          return true;
        });
        
        if (dedupedCurrent.length !== current.length) {
          console.log(`[mergeServerIncompleteRecords] ÂèëÁé∞ ${current.length - dedupedCurrent.length} Êù°ÈáçÂ§çÊú¨Âú∞ËÆ∞ÂΩïÔºåÂ∞ÜÂú®ÂêàÂπ∂Êó∂‰∏ÄÂπ∂Â§ÑÁêÜ`);
        }
        
        const byClientId = new Map(dedupedCurrent.map(r => [r.sessionId || r.id, r]));
        const updates = new Map();
        const toAppend: IncompleteHistoryRecord[] = [];
        let affected = 0;
        
        for (const serverRecord of serverRecords) {
          const clientId = serverRecord.client_id;
          console.log(`[mergeServerIncompleteRecords] Â§ÑÁêÜËÆ∞ÂΩï client_id: ${clientId}`);
          
          if (!clientId) {
            console.warn(`[mergeServerIncompleteRecords] Ë∑≥ËøáÊó†client_idËÆ∞ÂΩï:`, serverRecord);
            continue;
          }
          
          // ËΩ¨Êç¢ÊúçÂä°Á´ØËÆ∞ÂΩïÊ†ºÂºèÂà∞Êú¨Âú∞Ê†ºÂºè
          const canonical: IncompleteHistoryRecord = {
            id: clientId,
            sessionId: clientId,
            userId: userId,
            date: new Date(serverRecord.date).getTime(),
            problemType: serverRecord.problem_type,
            difficulty: serverRecord.difficulty,
            totalProblems: serverRecord.total_problems,
            correctAnswers: serverRecord.correct_answers,
            accuracy: serverRecord.accuracy,
            totalTime: serverRecord.total_time,
            averageTime: serverRecord.average_time,
            problems: serverRecord.problems,
            answers: serverRecord.answers,
            answerTimes: serverRecord.answer_times,
            score: serverRecord.score,
            plannedTotalProblems: serverRecord.planned_total_problems,
            synced: true, // ‰ªéÊúçÂä°Á´ØÊãâÂèñÁöÑËÆ∞ÂΩïÊ†áËÆ∞‰∏∫Â∑≤ÂêåÊ≠•
            timestamp: new Date(serverRecord.date).getTime() // ‰ΩøÁî®ÊúçÂä°Á´ØÊó∂Èó¥‰Ωú‰∏∫Êó∂Èó¥Êà≥
          };
          
          console.log(`[mergeServerIncompleteRecords] ËΩ¨Êç¢ÂêéÁöÑËÆ∞ÂΩï:`, canonical);
          
          const local = byClientId.get(clientId);
          if (local) {
            console.log(`[mergeServerIncompleteRecords] ÊâæÂà∞Êú¨Âú∞ËÆ∞ÂΩï:`, local);
            if (local.userId !== userId) {
              console.warn(`[mergeServerIncompleteRecords] ÂÜ≤Á™Å: Êú¨Âú∞ËÆ∞ÂΩï ${local.id} Â∑≤Â±û‰∫éÁî®Êà∑ ${local.userId}, ‰ΩÜÊúçÂä°Á´ØËÆ∞ÂΩïÂ±û‰∫é ${userId}`);
              continue;
            } else {
              // Âêå‰∏ÄË¥¶Âè∑‰∏ãÔºåÊ£ÄÊü•Êï∞ÊçÆÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞
              const needsUpdate = (
                local.date !== canonical.date ||
                local.score !== canonical.score ||
                local.correctAnswers !== canonical.correctAnswers ||
                local.totalProblems !== canonical.totalProblems ||
                local.accuracy !== canonical.accuracy ||
                local.totalTime !== canonical.totalTime ||
                local.synced !== canonical.synced
              );
              
              console.log(`[mergeServerIncompleteRecords] ÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞: ${needsUpdate}`);
              if (needsUpdate) {
                // ‰ºòÂÖà‰ΩøÁî®ÊúÄÊñ∞ÁöÑÊï∞ÊçÆÔºàÂü∫‰∫éÊó•ÊúüÔºâ
                if (canonical.date >= local.date) {
                  updates.set(clientId, canonical);
                  affected += 1;
                  console.log(`[mergeServerIncompleteRecords] Êõ¥Êñ∞Êú¨Âú∞ËÆ∞ÂΩï: ${clientId}`);
                } else {
                  console.log(`[mergeServerIncompleteRecords] ‰øùÁïôÊú¨Âú∞ËæÉÊñ∞Êï∞ÊçÆ: ${clientId}`);
                }
              } else {
                console.log(`[mergeServerIncompleteRecords] ËÆ∞ÂΩïÊó†ÈúÄÊõ¥Êñ∞: ${clientId}`);
              }
            }
          } else {
            // Êñ∞Êï∞ÊçÆÔºåÁõ¥Êé•Ê∑ªÂä†
            console.log(`[mergeServerIncompleteRecords] Ê∑ªÂä†Êñ∞ËÆ∞ÂΩï: ${clientId}`);
            toAppend.push(canonical);
            affected += 1;
          }
        }
        
        console.log(`[mergeServerIncompleteRecords] ÂæÖÊõ¥Êñ∞: ${updates.size}, ÂæÖÊ∑ªÂä†: ${toAppend.length}`);
        
        return { updates, toAppend, affected, dedupedCurrent };
      })();
      
      const { updates, toAppend, affected, dedupedCurrent } = processedData;
      
      // Ê£ÄÊü•ÊòØÂê¶Êúâ‰ªª‰ΩïÂèòÂåñÔºàÂåÖÊã¨ÂéªÈáçÂíåÂêàÂπ∂Ôºâ
      const hasDeduplication = dedupedCurrent.length !== current.length;
      const hasMergeChanges = updates.size > 0 || toAppend.length > 0;
      
      if (!hasDeduplication && !hasMergeChanges) {
        console.log(`[mergeServerIncompleteRecords] Êó†ÂèòÂåñÔºå‰∏çÊõ¥Êñ∞Áä∂ÊÄÅ`);
        return 0;
      }
      
      // ‰∏ÄÊ¨°ÊÄßÊõ¥Êñ∞Áä∂ÊÄÅÔºöÂü∫‰∫éÂéªÈáçÂêéÁöÑÊï∞ÊçÆËøõË°åÂêàÂπ∂
      setIncompleteHistoryRecords(() => {
        const next = dedupedCurrent.map(r => updates.get(r.sessionId || r.id) ?? r);
        if (toAppend.length > 0) next.unshift(...toAppend);
        console.log(`[mergeServerIncompleteRecords] ÊúÄÁªàÁä∂ÊÄÅÊõ¥Êñ∞: ${current.length} ‚Üí ${next.length} (ÂéªÈáç: ${hasDeduplication ? 'ÊòØ' : 'Âê¶'}, ÂêàÂπ∂: ${affected}Êù°)`);
        return next;
      });
      
      // Âè™ËøîÂõûÊñ∞ÂêàÂπ∂ÁöÑÊúçÂä°Á´ØËÆ∞ÂΩïÊï∞ÈáèÔºåÂéªÈáç‰∏çÁÆó‰Ωú"ÂêàÂπ∂"
      console.log(`[mergeServerIncompleteRecords] ÂêàÂπ∂ÂÆåÊàêÔºåÊñ∞Â¢û ${affected} Êù°ÊúçÂä°Á´ØËÆ∞ÂΩï ${hasDeduplication ? '(ÂêåÊó∂ËøõË°å‰∫ÜÂéªÈáç)' : ''}`);
      return affected;
    },
    // Ê†áËÆ∞Êú™ÂÆåÊàêËÆ∞ÂΩï‰∏∫Â∑≤ÂêåÊ≠•
    markIncompleteRecordAsSynced: (sessionId: string) => {
      setIncompleteHistoryRecords(prev => {
        const updated = prev.map(record => {
          if (record.sessionId === sessionId) {
            return { ...record, synced: true };
          }
          return record;
        });
        return updated;
      });
      return true;
    }
  };
};